---
title: 面试笔记
date: 2021-10-01 19:58:25
permalink: /pages/ba51d3/
sidebar: auto
categories:
  - 前端
  - 笔记
tags:
  -
---

## \$nextTick 的作用和原理

nextTick 相关源码的逻辑：

- nextTick 接受一个回调函数 cb 和一个 context 作为参数，将 cb push 到一个名为 callbacks 外部数组变量中，然后检查标识 callbacks 里的 cb 们是否正在执行的标记 pending 是否为 `false`，是的话则将之置为 `true`，并执行 timerFunc 函数
- timerFunc 的作用是在将 flushCallbacks 函数注册到任务队列中，可能是微任务队列，也可能是宏任务队列，取决于运行的环境是否支持如下 API：Promise、MutationObserver、setImmediate、setTimeout 之一，优先级依次降低
- flushCallbacks 的内部逻辑是
  1. 将 pending 置为 `false`
  2. copy 一个 callbacks 数组的副本
  3. 清空 callbacks
  4. 依次遍历执行 callbacks 副本里的回调函数

相关源码大致如下：

```
let callbacks = []
let pending = false
let timerFunc

function flushCallbacks() {
  const cbs = [...callbacks]

  callbacks.length = []
  pending = false

  for (let i = 0; i < cbs.length; ++i) {
    cbs[i]()
  }
}

if (support(Promise)) {
  timerFunc = () => Promise.resolve().then(flushCallbacks)
  // 省略 MutationObserver、setImmediate
} else {
  timerFunc = () => setTimeout(flushCallbacks)
}

function nextTick(cb, ctx) {
  callbacks.push(() => {
    if (cb) {
      cb.call(ctx)
    }
  })

  if (!pending) {
    pending = true
    timerFunc()
  }
}
```

## Event Loop 原理

- JavaScript 代码的执行是基于 event loop 机制的，这个机制可以简介为：特定代码的执行被当做一个任务注册到任务队列（先进先出），JavaScript 引擎执行完当前任务后会不停的尝试去任务队列里取下一个任务执行，循环往复、永不停息
- v8 引擎将任务分为宏任务和微任务。宏任务被注册到宏任务队列里，同时每个宏任务内部又对应一个微任务（ECMAScript 规范称之为 promiseJob，顾名思义是由 Promise 的 settlement 引发的）队列。每个任务的执行过程中（即执行对应的 JavaScript 代码）又可能会触发别的任务，触发的任务按照类别分别注册到对应的任务队列中
- 每个任务开始执行时都会创建与之对应的执行上下文，这些执行上下文会被 push 到执行上下文堆栈中，随着任务执行完成，相关的上下文也会被销毁，当执行上下文栈为空时即意味着当前任务执行完毕，引擎可以去任务队列去取新的任务执行。微任务执行完成的标记是执行上下文堆栈为空，而宏任务执行完成的标记是除了执行上下文堆栈为空以外还要求此宏任务对应的微任务队列为空

## Proxy 和 Reflect

ES6 新增的两个对象，用于增加 ES 元编程的能力。
Proxy 是一个构造函数，接受两个参数，第一个是被代理的对象 target（必须是对象，如果是简单类型的值会报 TypeError），第二个参数是一个可以包含 13 方法的对象，13 个方法被称为 trap，每个 trap 可以对一些特定的基于对象的操作进行拦截从而实现代理的功能，构造函数返回一个 proxy 实例，对 target 的操作都可以借由对 proxy 进行相同的操作来完成。

Proxy 还有个 `Proxy.revocable` 静态方法，作用是创建一个可以解除代理的 proxy，方法的返回值是一个对象，包括一个通过 `new Proxy` 创建的 proxy 实例和一个解除代理的方法 revoke，调用 revoke 后 proxy 实例的内部属性 `proxy.[[revocable]]` 值则变为 `true`，同时，对 proxy 的操作则会报 TypeError。

Reflect 也是一个对象，与 Proxy 不同，它不是函数，而是一个包含 13 个方法的数据属性，这 13 个方法与 `new Proxy` 第二个参数中的 13 个 trap 对应。Reflect 的不少方法与 Object 上的一些方法具有相同作用，但也有些细微区别（比如返回值不通，参数校验机制不同）。

## 箭头函数与一般函数的区别

- 箭头函数只能通过变量赋值的方式创建
- 箭头函数没有 prototype，所以也不能作为构造函数
- 箭头函数无法绑定 this 值，内部的 this 值是按照词法作用域确定的
