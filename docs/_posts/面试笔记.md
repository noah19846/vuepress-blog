---
title: 面试笔记
date: 2021-10-01 19:58:25
permalink: /pages/ba51d3/
sidebar: auto
categories:
  - 前端
  - 笔记
tags:
  -
---

## \$nextTick 的作用和原理

nextTick 相关源码的逻辑：

- nextTick 接受一个回调函数 cb 和一个 context 作为参数，将 cb push 到一个名为 callbacks 外部数组变量中，然后检查标识 callbacks 里的 cb 们是否正在执行的标记 pending 是否为 `false`，是的话则将之置为 `true`，并执行 timerFunc 函数
- timerFunc 的作用是在将 flushCallbacks 函数注册到任务队列中，可能是微任务队列，也可能是宏任务队列，取决于运行的环境是否支持如下 API：Promise、MutationObserver、setImmediate、setTimeout 之一，优先级依次降低
- flushCallbacks 的内部逻辑是
  1. 将 pending 置为 `false`
  2. copy 一个 callbacks 数组的副本
  3. 清空 callbacks
  4. 依次遍历执行 callbacks 副本里的回调函数

相关源码大致如下：

```
let callbacks = []
let pending = false
let timerFunc

function flushCallbacks() {
  const cbs = [...callbacks]

  callbacks.length = []
  pending = false

  for (let i = 0; i < cbs.length; ++i) {
    cbs[i]()
  }
}

if (support(Promise)) {
  timerFunc = () => Promise.resolve().then(flushCallbacks)
  // 省略 MutationObserver、setImmediate
} else {
  timerFunc = () => setTimeout(flushCallbacks)
}

function nextTick(cb, ctx) {
  callbacks.push(() => {
    if (cb) {
      cb.call(ctx)
    }
  })

  if (!pending) {
    pending = true
    timerFunc()
  }
}
```

## Event Loop 原理

- JavaScript 代码的执行是基于 event loop 机制的，这个机制可以简介为：特定代码的执行被当做一个任务注册到任务队列（先进先出），JavaScript 引擎执行完当前任务后会不停的尝试去任务队列里取下一个任务执行，循环往复、永不停息
- v8 引擎将任务分为宏任务和微任务。宏任务被注册到宏任务队列里，同时每个宏任务内部又对应一个微任务（ECMAScript 规范称之为 promiseJob，顾名思义是由 Promise 的 settlement 引发的）队列。每个任务的执行过程中（即执行对应的 JavaScript 代码）又可能会触发别的任务，触发的任务按照类别分别注册到对应的任务队列中
- 每个任务开始执行时都会创建与之对应的执行上下文，这些执行上下文会被 push 到执行上下文堆栈中，随着任务执行完成，相关的上下文也会被销毁，当执行上下文栈为空时即意味着当前任务执行完毕，引擎可以去任务队列去取新的任务执行。微任务执行完成的标记是执行上下文堆栈为空，而宏任务执行完成的标记是除了执行上下文堆栈为空以外还要求此宏任务对应的微任务队列为空
