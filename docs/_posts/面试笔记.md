---
title: 面试笔记
date: 2021-10-01 19:58:25
permalink: /pages/ba51d3/
sidebar: auto
categories:
  - 前端
  - 笔记
tags:
  -
---

## \$nextTick 的作用和原理

nextTick 相关源码的逻辑：

- nextTick 接受一个回调函数 cb 和一个 context 作为参数，将 cb push 到一个名为 callbacks 外部数组变量中，然后检查标识 callbacks 里的 cb 们是否正在执行的标记 pending 是否为 `false`，是的话则将之置为 `true`，并执行 timerFunc 函数
- timerFunc 的作用是在将 flushCallbacks 函数注册到任务队列中，可能是微任务队列，也可能是宏任务队列，取决于运行的环境是否支持如下 API：Promise、MutationObserver、setImmediate、setTimeout 之一，优先级依次降低
- flushCallbacks 的内部逻辑是
  1. 将 pending 置为 `false`
  2. copy 一个 callbacks 数组的副本
  3. 清空 callbacks
  4. 依次遍历执行 callbacks 副本里的回调函数

相关源码大致如下：

```
let callbacks = []
let pending = false
let timerFunc

function flushCallbacks() {
  const cbs = [...callbacks]

  callbacks.length = []
  pending = false

  for (let i = 0; i < cbs.length; ++i) {
    cbs[i]()
  }
}

if (support(Promise)) {
  timerFunc = () => Promise.resolve().then(flushCallbacks)
  // 省略 MutationObserver、setImmediate
} else {
  timerFunc = () => setTimeout(flushCallbacks)
}

function nextTick(cb, ctx) {
  callbacks.push(() => {
    if (cb) {
      cb.call(ctx)
    }
  })

  if (!pending) {
    pending = true
    timerFunc()
  }
}
```

## Event Loop 原理

- JavaScript 代码的执行是基于 event loop 机制的，这个机制可以简介为：特定代码的执行被当做一个任务注册到任务队列（先进先出），JavaScript 引擎执行完当前任务后会不停的尝试去任务队列里取下一个任务执行，循环往复、永不停息
- v8 引擎将任务分为宏任务和微任务。宏任务被注册到宏任务队列里，同时每个宏任务内部又对应一个微任务（ECMAScript 规范称之为 promiseJob，顾名思义是由 Promise 的 settlement 引发的）队列。每个任务的执行过程中（即执行对应的 JavaScript 代码）又可能会触发别的任务，触发的任务按照类别分别注册到对应的任务队列中
- 每个任务开始执行时都会创建与之对应的执行上下文，这些执行上下文会被 push 到执行上下文堆栈中，随着任务执行完成，相关的上下文也会被销毁，当执行上下文栈为空时即意味着当前任务执行完毕，引擎可以去任务队列去取新的任务执行。微任务执行完成的标记是执行上下文堆栈为空，而宏任务执行完成的标记是除了执行上下文堆栈为空以外还要求此宏任务对应的微任务队列为空

## Proxy 和 Reflect

ES6 新增的两个对象，用于增加 ES 元编程的能力。
Proxy 是一个构造函数，接受两个参数，第一个是被代理的对象 target（必须是对象，如果是简单类型的值会报 TypeError），第二个参数是一个可以包含 13 方法的对象，13 个方法被称为 trap，每个 trap 可以对一些特定的基于对象的操作进行拦截从而实现代理的功能，构造函数返回一个 proxy 实例，对 target 的操作都可以借由对 proxy 进行相同的操作来完成。

Proxy 还有个 `Proxy.revocable` 静态方法，作用是创建一个可以解除代理的 proxy，方法的返回值是一个对象，包括一个通过 `new Proxy` 创建的 proxy 实例和一个解除代理的方法 revoke，调用 revoke 后 proxy 实例的内部属性 `proxy.[[revocable]]` 值则变为 `true`，同时，对 proxy 的操作则会报 TypeError。

Reflect 也是一个对象，与 Proxy 不同，它不是函数，而是一个包含 13 个方法的数据属性，这 13 个方法与 `new Proxy` 第二个参数中的 13 个 trap 对应。Reflect 的不少方法与 Object 上的一些方法具有相同作用，但也有些细微区别（比如返回值不通，参数校验机制不同）。

## 箭头函数与一般函数的区别

- 箭头函数只能通过变量赋值的方式创建
- 箭头函数没有 prototype，所以也不能作为构造函数
- 箭头函数无法绑定 this 值，内部的 this 值是按照词法作用域确定的

## Vue 组件的异步更新原理

- 响应式数据 get -> 通过调用响应式数据对应的 dep.depend() 使 dep 和对应 watcher 建立关联
- 响应式数据 set -> dep.notify() -> 订阅 dep 的 watchers 调用 watcher.update()

watcher.update 分三种情况 lazy-watcher、同步 watcher、一般 watcher：

1. lazy -> watcher.dirty = true
2. sync -> watcher.run()
3. queueWatcher(watcher)

queueWatcher 的逻辑：

1. 如果 `queueWatcher(watcher)` 时 flushing 为 `false` 说明 `queueWatcher(watcher)` 并非由 `watcher.run()` 触发的，这样完全不会有什么问题，所有的 watcher 都会在下一个微任务中执行自己的 run
2. 相反，如果 `queueWatcher(watcher)` 时 flushing 为 `true` 则说明这个 watcher 是由 flushSchedulerQueue 中某个 `watcher.run()` 触发的，此时由于已知 flushSchedulerQueue 中已经按 `watcher.id` 从小到大排序的 queue 中正在 run 的 watcher 的 index，所以可以对比 `watcher.id` 然后通过 `queue.splice` 方法将要 queue 的 watcher 插入到 index 之后的某个位置，从而保证将此 watcher 能以正确的顺序 run
3. 如果 flushSchedulerQueue 未被 push 到 nextTick 对应的异步回调队列中（通过标记为 waiting 是否为 `false` 判断），则将 waiting 置为 `true` 并执行 `nextTick(flushSchedulerQueue)`

flushSchedulerQueue 开始时会将 flushing 置为 `true`，然后将遍历执行 queue 中的 `watcher.run()` 之前会将 queue 按 `watcher.id` 从小到大排序，以保证

1. 父组件的 render-watcher run 于其子组件的 render-watcher 之前
2. 用户创建的 watcher run 于其所属组件 vm 的 render-watcher 之前

也即 watcher 的 update 顺序与其创建顺序一致，先创建的 watcher 对应的 id 小。但是对应 vm 的 updated hook 是先子后父的，因为在 callUpdatedHooks 中触发 update hook 的顺序是反过来的。

遍历执行 queue 里的 `watcher.run()` 后会执行 `resetSchedulerState()`，即将 waiting、flushing 重新置为`false`，以及将 queue 相关的数据都置空，已准备开始下一轮的 queueWatcher。

详见[组件的 update](https://juejin.cn/post/6900195618430386183#heading-12)

## http 状态码

1. Informational 1xx

此类状态代码表示临时响应，仅由状态行和可选 headers 组成，并且以空行结束。

- 100 Continue
- 101 Switching Protocols

2. Successful 2xx

此类状态码表示客户端的请求被成功地接受、理解和接受。

- 200 OK：请求已成功
- 201 Created：请求完成并且导致已经创建新资源
- 202 Accepted：请求完成并且到桌将要创建新资源
- 203 Non-Authoritative Information
- 204 No Content：请求已完成但是不需要返回 body
- 205 Reset Content：请求已完成，用户代理应该重置导致请求发送的文档视图
- 206 Partial Content：服务器已完成 GET 对资源的部分请求

3. Redirection 3xx

此类状态码表示客户端需要采取进一步操作以完成请求。

- 300 Multiple Choices
- 301 Moved Permanently：永久重定向，后续请求的 URI 应该使用 response 返回的新 URI
- 302 Found：临时重定向，后续请求的 URI 还是使用当前 URI
- 303 See Others：临时重定向，后续请求的 URI 还是使用当前 URI，对重定向的资源必须使用 GET 方法请求
- 304 Not Modified：用于缓存未修改时的 response，对应 response 没有 body
- 305 Use Proxy：请求的资源必须通过 proxy 进行访问
- 306 (Unused)
- 307 Temporary Redirect：临时重定向，后续请求的 URI 还是使用当前 URI

4. Client Error 4xx

- 400
- ...
- ...
- ...
- 417

5. Server Error 5xx

- 500
- 501
- 502
- 503
- 504
- 506
